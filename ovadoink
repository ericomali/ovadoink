#!/usr/bin/env python
#
# LICENSE
# Copyright 2017 Eric Melville
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice,
# this list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright notice,
# this list of conditions and the following disclaimer in the documentation
# and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#
# DESCRIPTION
# ovadoink - swiss army knife for OVA manipulation
#
# There are many, many features missing from ovftool. This is an attempt to
# fill in some of them, but is in no way exhaustive. Features tend to get added
# as the author needs them; suggestions and improvements are more than welcome.
#
# HISTORY
# 0.2 - Added -t for hardware type and only update manifest if -m specified
# 0.1 - Initial version, no options, simply updates signatures in manifest file
#
# PREHISTORIC
# The author created a previous incarnation of this tool called vmxconv for an
# employer, which was not licensed for open distribution though some copies
# have been found publicly floating about. That employer is now defunct and is
# believed to have supported the release of vmxconv, but any users of that tool
# would probably be better served by moving to this one.
#
# TODO
# Option for removing audio hardware
# Preserve XML namespace names
# Verbose vs quiet

import argparse
import hashlib
import os
import re
import shutil
import sys
import tarfile
import tempfile
import xml.etree.ElementTree as ET

def checksha(filename, manifest, verbose):
    mfd = open(manifest, 'r')
    cre = re.compile(r'SHA(\d*)\((.*)\)=\ (.*)')
    sha = None
    hash = None

    # pick up hash type and data from manifest; let unknowns fall through
    line = mfd.readline()
    while line:
        res = cre.match(line)
        if res.group(2) == filename:
            sha = res.group(1)
            hash = res.group(3)
        line = mfd.readline()

    # calculate actual file checksum from disk
    fd = open(filename, 'r')
    dat = fd.read()
    if sha == "1":
        calc = hashlib.sha1(dat)
    elif sha == "256":
        calc = hashlib.sha256(dat)
    else:
        calc = hashlib.sha1("bogus")  # also picks up files not in manifest

    return calc.hexdigest() == hash

name = 'ovadoink'
desc = 'swiss army knife for OVA manipulation'
version = 0.2

verbose = True
verify = False

if sys.argv[1] == '--version':
    print "%s - %s" % (name, desc)
    print "version %s" % (str(version))
    sys.exit(0)

parser = argparse.ArgumentParser(description=desc)
parser.add_argument('-m', '--manifest', action='store_true', help='generate manifest')
parser.add_argument('-n', '--netif', help='set interface type eg. "82540EM"')
parser.add_argument('-t', '--type', metavar='HWTYPE', help='set hardware type eg. "vmx-11"')
parser.add_argument('ova', metavar='file.ova', help='file name')
args = parser.parse_args()

# somewhat convoluted, but set verify if no write options were specified
if not args.type and not args.netif and not args.manifest:
    verify = True

ova = args.ova
pfd = open(ova, mode='r')
tar = tarfile.open(fileobj=pfd, mode='r')
temp = tempfile.mkdtemp()

flist = tar.getnames()
badfile = False
for x in flist:
    if x[0] == '/' or x[0:2] == '..':
        badfile = True
if len(flist) < 2 or badfile == True:
    print "OVA file appears bougs"
    sys.exit(1)

tar.extractall(path=temp)
tar.close()
pfd.close()
oldwd = os.getcwd()
os.chdir(temp)

ovf = None
mf = None
badlist = []
checko = re.compile(r'.*\.[Oo][Vv][Ff]$')
checkm = re.compile(r'.*\.[Mm][Ff]$')
checkb = re.compile(r'.*\/\._.*')

# special case OVF and manifest, and remove AppleDouble aka ._ files outright
for x in flist:
    if checko.match(x):
        ovf = x
    if checkm.match(x):
        mf = x
    if checkb.match(x):
        badlist.append(x)

if ovf == None:
    print "Error, no OVF found in OVA."
    sys.exit(1)

# ensure ovf is first in the archive
flist.remove(ovf)
flist.insert(0, ovf)

if mf:
    flist.remove(mf)
for x in badlist:
    if verbose and verify:
        print "ignoring bogus file %s" % (x)
    elif verbose:
        print "removing bogus file %s" % (x)
    flist.remove(x)

# generate manifest if desired
if args.manifest:
    mf = ovf[:-3]
    mf = mf + "mf"  # do not care

    if os.path.isfile(mf):
        os.remove(mf)
    mfd = open(mf, 'w')
    for x in flist:
        if os.path.isfile(x):
            xfd = open(x, 'r')
            dat = xfd.read()
            hash = hashlib.sha1(dat)
            str = "SHA1(%s)= %s\n" % (x, hash.hexdigest())
            mfd.write(str)
    mfd.close()
    flist.insert(1, mf)

# fudge hardware type if requested
if args.type:
    xml = ET.parse(ovf)
    nsf = re.compile(r'\{.*\}(.*)')
    for x in xml.iter():
        res = nsf.search(x.tag)
        if res.group(1) == "VirtualSystemType":
            x.text = args.type
    xml.write(ovf)

# rewrite network adaptor types if requested
if args.netif:
    xml = ET.parse(ovf)
    nsf = re.compile(r'\{.*\}(.*)')
    for x in xml.iter():
        res = nsf.search(x.tag)
        if res.group(1) == "Adapter":
            x.attrib['type'] = args.netif
    xml.write(ovf)

# remove old tar and create new one in place
fullpath = None
if ova[0] == '/':
    fullpath = ova
else:
    fullpath = "%s/%s" % (oldwd, ova)

# well unless it was only a verification operation
if verify == False:
    os.remove(fullpath)
    tar = tarfile.open(name=fullpath, mode='w')
    for x in flist:
        tar.add(x, recursive=False)
    tar.close()
else:
    allgood = True
    for x in flist:
        if checksha(x, mf, verbose) == False:
            allgood = False

    if allgood == False:
        print "Manifest verification failed."
        sys.exit(1)

# remove temp files
shutil.rmtree(temp)
